import { Button, DatePicker, HBox, Input, Select, Switches, Table, TableRow, Text, TextArea, VBox } from "./Component.js";

async function get(url) {
    const res = await fetch(url);
    const data = await res.json();
    return data;
}

async function post(url, body_obj) {
    const res = await fetch(url, {
        method: 'post',
        body: JSON.stringify(body_obj),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    return await res.json();
}


let SystemHttpServerInfoCache = null;
/** 获取后台系统的http服务器信息缓存 */
async function getSystemHttpServerInfoCache() {
    if (SystemHttpServerInfoCache) {
        return SystemHttpServerInfoCache;
    }
    const info_str = await local.getSystemHttpServerInfo();
    if (info_str) {
        const info = JSON.parse(info_str);
        SystemHttpServerInfoCache = info;
        return info;
    }
    return null;
}

/** 获取作业定义表信息 */
async function getJobInfoById(job_id) {
    const http_info = await getSystemHttpServerInfoCache();
    const res = await get(`http://${http_info.host}:${http_info.port}?action=get_job_info_by_id&job_id=${job_id}`);
    const cron = res.data.cron;
    const job_name = res.data.job_name;
    const job_type = res.data.job_type;
    return { job_id, job_name, job_type, cron };
}

export class PaneContent {
    constructor(id, param) {
        this.id = id;
        this.param = param || null;
        this.dom = document.createElement('div');
        this.start();
    }

    start() {
        /* 构建页面布局、定义响应 */
    }
}

export class MainPage extends PaneContent {
    constructor(id) {
        super(id);
    }
    start() {
        const component = new VBox({
            children: [
                new Text({ text: '这是主页书架，未来需要放置放入书架的小说' }),
                new Text({ text: '作者: ty' }),
            ]
        });
        this.dom = component.html();
    }
}

export class SearchList extends PaneContent {
    constructor(id) {
        super(id);
    }
    start() {
        this.job_table = new Table({
            columns: ['作业ID', '作业名称', '规则ID', '下次执行时间', '状态', '操作'],
            children: []
        });
        this.job_id_input = new Input({ type: "text", class_list: ['form-control-sm'] });
        this.job_name_input = new Input({ type: "text", class_list: ['form-control-sm'] });
        this.search_btn = new Button({
            text: "查询结果",
            class_list: ['text-nowrap', 'btn-primary'],
            onclick: async () => {
                this.updateJobList();
            }
        });
        this.add_btn = new Button({
            text: "新增作业",
            class_list: ['text-nowrap', 'btn-primary'],
            onclick: async () => {
                const e = new CustomEvent('add-page', {
                    detail: {
                        id: 'job-editer-new',
                        name: "新建作业",
                        content: JobEditer
                    },
                    bubbles: false
                });
                document.dispatchEvent(e);
            }
        });
        const component = new VBox({
            children: [
                new HBox({
                    children: [
                        new Text({ text: "作业ID: ", class_list: ['text-nowrap'] }),
                        this.job_id_input,
                        new Text({ text: "作业名称: ", class_list: ['text-nowrap'] }),
                        this.job_name_input,
                        this.search_btn,
                        this.add_btn,
                    ]
                }),
                new VBox({
                    class_list: ['flex-grow-1'],
                    children: [this.job_table]
                })
            ]
        });
        this.dom = component.html();
    }

    createCurrentRunButton(job_id, host, port) {
        return new Button({
            text: '立即启动',
            class_list: ['text-nowrap', 'btn-success', 'btn-sm'],
            onclick: async () => {
                const info = await getJobInfoById(job_id);
                if (info.job_type == 'regularly_job') {
                    const date = new Date();
                    const year = date.getFullYear();
                    const month = (date.getMonth() + 1 + "").padStart(2, '0');
                    const day = ("" + date.getDate()).padStart(2, '0');
                    const hour = (date.getHours() + "").padStart(2, '0');
                    const minutes = (date.getMinutes() + "").padStart(2, '0');
                    const seconds = ("" + date.getSeconds()).padStart(2, 0);
                    const date_str = `${year}-${month}-${day} ${hour}:${minutes}:${seconds}`;
                    const res = await get(`http://${host}:${port}?action=set_job_next_time&job_id=${job_id}&next_time=${date_str}`);
                    console.log("设置作业立即启动：", res);
                } else if (info.job_type == 'immediately_job') {
                    const res = await get(`http://${host}:${port}?action=set_immediately_job_run&job_id=${job_id}`); 
                    console.log("设置立即执行作业启动：", res);
                } else {
                    console.log("这个作业的作业类型异常");
                }
                
                this.updateJobList();
            }
        });
    }
    createJobEditerButton(job_id, job_name) {
        return new Button({
            text: '编辑作业', class_list: ['text-nowrap', 'btn-primary', 'btn-sm'], onclick: async () => {
                const e = new CustomEvent('add-page', {
                    detail: {
                        id: 'job-editer-' + job_id,
                        name: "编辑作业-" + job_name,
                        param: { job_id, job_name },
                        content: JobEditer
                    },
                    bubbles: false
                });
                document.dispatchEvent(e);
            }
        });
    }
    createRuleEditerButton(job_id, job_name, rule_id) {
        return new Button({
            text: '编辑规则', class_list: ['text-nowrap', 'btn-primary', 'btn-sm'], onclick: async () => {
                const e = new CustomEvent('add-page', {
                    detail: {
                        id: 'rule-edit-' + job_id,
                        name: '编辑规则-' + job_name,
                        content: RuleEditer,
                        param: { job_id, rule_id, job_name }
                    },
                    bubbles: false
                });
                document.dispatchEvent(e);
            }
        });
    }
    createJobItemDeleteButton(job_id, job_name, host, port) {
        return new Button({
            text: '删除', class_list: ['text-nowrap', 'btn-danger', 'btn-sm'], onclick: async () => {
                const flag = await local.showConfirmDialog(`请确认是否删除作业？ ${job_name}`);
                if (flag > 0) {
                    const res = await get(`http://${host}:${port}?action=del_job&job_id=${job_id}`);
                    console.log('获取当前删除作业后的返回值：', res);
                    this.updateJobList();
                }
            }
        });
    }
    createStateSwitches(job_id, status, host, port) {
        return new Switches({
            is_checked: (status == 1 ? true : false),
            onclick: async (_is_checked) => {
                const res = await get(`http://${host}:${port}?action=change_job_state&job_id=${job_id}&status=${_is_checked ? 1 : 0}`);
                console.log("改变作业状态：", res);
            }
        });
    }
    createJobTableRow(job_id, job_name, rule_id, next_time, status, host, port) {
        return new TableRow({
            children: [job_id, job_name, rule_id, next_time,
                this.createStateSwitches(job_id, status, host, port),
                new HBox({
                    children: [
                        this.createCurrentRunButton(job_id, host, port),
                        this.createJobEditerButton(job_id, job_name),
                        this.createRuleEditerButton(job_id, job_name, rule_id),
                        this.createJobItemDeleteButton(job_id, job_name, host, port)
                    ]
                })
            ]
        });
    }

    async updateJobList() {
        const info = await getSystemHttpServerInfoCache();
        const args = {};
        args.job_id = { key: "job_id", value: this.job_id_input.value(), condition: 'equles' };
        args.job_name = { key: "job_name", value: this.job_name_input.value(), condition: 'like' };
        const effect_args = Object.keys(args).filter((k) => { return args[k].value }).reduce((dict, cur_key) => { dict[cur_key] = args[cur_key]; return dict; }, {});
        // const res = await get(`http://${info.host}:${info.port}?action=get_job_list`);
        const res = await post(`http://${info.host}:${info.port}`, { action: 'get_job_list', where: effect_args });
        console.log("获取作业列表：", res);
        this.job_table.children = [];
        for (const job of res.data) {
            const { job_id, job_name, next_time, rule_id, status } = job;
            const row = this.createJobTableRow(job_id, job_name, rule_id, next_time, status, info.host, info.port);
            this.job_table.children.push(row);
        }
        this.job_table.update();
    }

}

export class RuleEditer extends PaneContent {
    constructor(id, param) {
        super(id, param);
        this.rules = {
            print_line: { name: "向文件打印一行文字" },
            exec_command: { name: '执行终端命令' }
        }
    }
    start() {
        this.job_id = this.param?.job_id;
        this.rule_id = this.param?.rule_id;
        this.job_name = this.param?.job_name;
        this.title = new Text({ text: `作业名称: ${this.job_name}` });
        this.add_item_btn = new Button({
            text: '新增规则项目',
            class_list: ['text-nowrap', 'btn-primary', 'btn-sm', 'ms-auto'],
            onclick: () => {
                this.rule_item_table.addRow(new TableRow({
                    children: [
                        new Select({ options: this.rules }),
                        new Input({ type: 'input' }),
                        new TextArea()
                    ]
                }));
            }
        });
        this.save_btn = new Button({
            text: "保存当前规则",
            class_list: ['text-nowrap', 'btn-primary', 'btn-sm'],
            onclick: async () => {
                const rule_items = this.getRuleItems();
                console.log('获取当前规则列表：', rule_items);
                if (rule_items && rule_items.length > 0) {
                    const info = await getSystemHttpServerInfoCache();
                    const res = await post(`http://${info.host}:${info.port}`, {
                        action: 'save_rule_list',
                        rule_list: rule_items,
                        rule_id: this.rule_id
                    });
                    console.log("保存规则列表返回值：", res);
                }
            }
        });
        this.refresh_btn = new Button({
            text: "手动刷新重置",
            class_list: ['text-nowrap', 'btn-primary', 'btn-sm'],
            onclick: () => { this.updateRuleItem(); }
        });
        this.rule_item_table = new Table({ columns: ['规则类型', '规则名称', 'context'] });
        const component = new VBox({
            children: [
                new HBox({
                    children: [this.title, this.add_item_btn, this.save_btn, this.refresh_btn]
                }),
                this.rule_item_table
            ]
        });
        this.dom = component.html();
        this.updateRuleItem();
    }
    /** 更新规则对象 */
    async updateRuleItem() {
        const info = await getSystemHttpServerInfoCache();
        const res = await get(`http://${info.host}:${info.port}?action=get_rule_items&job_id=${this.job_id}`);
        console.log("获取数据库规则列表：", res);
        const rule_list = res.data;
        if (rule_list.length == 0) {
            this.rule_item_table.clearAll();
            return;
        } else {
            const row_list = [];
            for (const rule of rule_list) {
                const type_input = new Select({ options: this.rules });
                const name_input = new Input({ type: 'input' });
                const context_input = new TextArea();
                type_input.value(rule.action_type);
                name_input.value(rule.action_name);
                context_input.value(rule.context);
                const row = new TableRow({
                    children: [type_input, name_input, context_input]
                });
                row_list.push(row);
            }
            this.rule_item_table.clearAll();
            this.rule_item_table.children = row_list;
            this.rule_item_table.update();
        }
    }
    /** 判断当前规则项目是否正确， 正确就返回可以保存到后台的规则列表 */
    getRuleItems() {
        if (this.rule_item_table.children.length == 0) return null;
        let rule_items = [];
        for (const row of this.rule_item_table.children) {
            const type_i = row.children[0];
            const name_i = row.children[1];
            const context_i = row.children[2];
            if (type_i.isEmpty() || name_i.isEmpty() || context_i.isEmpty()) {
                return null;
            }
            rule_items.push([type_i.value(), name_i.value(), context_i.value()]);
        }
        return rule_items;
    }

}

export class JobEditer extends PaneContent {
    constructor(id, param) {
        super(id, param);
    }
    start() {
        const name_input = new Input({ type: 'text' });
        const cron_input = new Input({ type: 'text' });
        const type_select = new Select({
            options: { regularly_job: { name: "定时作业" }, immediately_job: { name: "立即执行作业" } },
            onchange: (e) => {
                if (e.target.value == 'regularly_job') {
                    cron_input.value('');
                } else {
                    cron_input.value('-');
                }
            }
        });
        const component = new VBox({
            children: [
                new HBox({
                    children: [
                        new Text({ text: "作业名称: ", class_list: ['text-nowrap'] }),
                        name_input,
                        new Text({ text: "作业类型", class_list: ['text-nowrap'] }),
                        type_select,
                    ]
                }),
                new HBox({
                    children: [
                        new Text({ text: "CRON表达式: ", class_list: ['text-nowrap'] }),
                        cron_input
                    ]
                }),
                new HBox({
                    children: [
                        new Button({
                            text: '提交',
                            class_list: ['text-nowrap', 'btn-primary'],
                            onclick: async () => {
                                const jobname = name_input.value();
                                const jobtype = type_select.value();
                                const cron = cron_input.value();

                                if (!(jobname) && !(cron)) {
                                    alert("错误！ 作业名称或cron表达式为空");
                                    return;
                                }
                                const info = await getSystemHttpServerInfoCache();
                                if (this.param && this.param.job_id) {
                                    const res = await get(`http://${info.host}:${info.port}?action=update_job_name_and_cron&job_id=${this.param.job_id}&name=${jobname}&type=${jobtype}&cron=${cron}`);
                                    console.log("请求更新作业，返回：", res);
                                    const ev = new CustomEvent('close-page', { detail: { id: this.id } });
                                    document.dispatchEvent(ev);
                                } else {
                                    /* 作业新增 */
                                    const res = await get(`http://${info.host}:${info.port}?action=add_job&name=${jobname}&type=${jobtype}&cron=${cron}`);
                                    console.log("请求新增作业，返回：", res);
                                    const { job_id, is_created, error_msg } = res.data;
                                    if (is_created) {
                                        const ev = new CustomEvent('close-page', { detail: { id: 'job-editer-new' } });
                                        document.dispatchEvent(ev);
                                    } else {
                                        alert(error_msg);
                                    }
                                }
                            }
                        })
                    ]
                })
            ]
        });
        this.dom = component.html();

        const job_id = this.param?.job_id;
        if (job_id) {
            getJobInfoById(job_id).then((val) => {
                console.log("获取作业信息：", val);
                name_input.value(val.job_name);
                type_select.value(val.job_type);
                cron_input.value(val.cron);
            });
        }
    }

}

export class JobWorkMoniter extends PaneContent {
    constructor(id) {
        super(id);
    }
    start() {
        this.job_work_item_table = new Table({ columns: ['任务ID', '作业ID', '作业名称', '规则ID', '状态', '插入时间', '开始时间', '结束时间'] });
        this.job_id_input = new Input({ type: 'text', class_list: ['form-control-sm'] });
        this.job_name_input = new Input({ type: 'text', class_list: ['form-control-sm'] });
        this.insert_time_input = new DatePicker({});
        this.search_btn = new Button({
            text: '搜索',
            class_list: ['text-nowrap', 'btn-primary'],
            onclick: () => {
                this.updateJobWorkList();
            }
        });
        const component = new VBox({
            children: [
                new HBox({
                    children: [
                        new Text({ text: "作业ID", class_list: ['text-nowrap'] }),
                        this.job_id_input,
                        new Text({ text: "作业名称", class_list: ['text-nowrap'] }),
                        this.job_name_input,
                        new Text({ text: "插入时间", class_list: ['text-nowrap'] }),
                        this.insert_time_input,
                        this.search_btn
                    ]
                }),
                this.job_work_item_table
            ]
        });
        this.dom = component.html();
        this.updateJobWorkList();
    }
    createNewRow(task_id, job_id, job_name, rule_id, status, insert_time, exec_time, finish_time) {
        return new TableRow({
            children: [task_id, job_id, job_name, rule_id, status, insert_time, exec_time, finish_time]
        });
    }
    statusTrans(status) {
        return (['队列等待', '完成', '失败', '正在执行'])[status]
    }
    async updateJobWorkList() {
        const info = await getSystemHttpServerInfoCache();
        const args = {};
        args.job_id = { key: "job_id", value: this.job_id_input.value(), condition: 'equles' };
        args.job_name = { key: "job_name", value: this.job_name_input.value(), condition: 'like' };
        const iv = this.insert_time_input.value();
        args.insert_time = { key: 'insert_time', value: { start: iv?.start, end: iv?.end }, condition: 'between' };
        const effect_args = Object.keys(args).filter((k) => { return args[k].value }).reduce((dict, cur_key) => { dict[cur_key] = args[cur_key]; return dict; }, {});
        let res = {};
        if (Object.keys(effect_args).length == 0) {
            res = await get(`http://${info.host}:${info.port}?action=get_task_list`);
        } else {
            res = await post(`http://${info.host}:${info.port}`, { action: 'get_task_list_by_param', where: effect_args });
        }
        console.log("获取数据库任务执行列表：", res);
        const task_list = res.data || [];
        if (task_list.length == 0) {
            this.job_work_item_table.clearAll();
            return;
        } else {
            const row_list = [];
            for (const task of task_list) {
                const { task_id, job_id, job_name, rule_id, status, insert_time, exec_time, finish_time } = task;
                const row = this.createNewRow(task_id, job_id, job_name, rule_id, this.statusTrans(status), insert_time, exec_time, finish_time);
                row_list.push(row);
            }
            this.job_work_item_table.clearAll();
            this.job_work_item_table.children = row_list;
            this.job_work_item_table.update();
        }
    }
    getInsertDatetimeValue() {
        const idv = this.insert_time_input.value();
        if (iv) {
            const { start, end } = iv;
            args.insert_time = { key: 'insert_time', value: { start: start, end: end }, condition: 'between' };
        } else {
            return null;
        }
    }
}

export class SystemMoniter extends PaneContent {
    constructor(id) { super(id); }
    start() {
        this.pid_componet = new Text({ text: "" });
        this.local_http_port = new Text({ text: '' });
        this.mem_rss_text = new Text({ text: "" });
        this.mem_heap_total_text = new Text({ text: "" });
        this.mem_heap_used_text = new Text({ text: "" });
        this.mem_external_text = new Text({ text: "" });
        this.state_componet = new Text({ text: "" });
        this.component = new VBox({
            children: [
                new HBox({
                    children: [
                        new Button({
                            text: "刷新",
                            class_list: ['text-nowrap', 'btn-primary', 'btn-sm'],
                            onclick: () => { this.updateInfo(); }
                        }),
                    ]
                }),
                this.state_componet,
                this.pid_componet,
                this.local_http_port,
                new Text({ text: '内存信息：' }),
                this.mem_rss_text,
                this.mem_heap_total_text,
                this.mem_heap_used_text,
                this.mem_external_text,
            ]
        });
        this.dom = this.component.html();
        this.updateInfo();
    }

    async updateInfo() {
        const info = await getSystemHttpServerInfoCache();
        try {
            const res = await get(`http://${info.host}:${info.port}?action=get_system_state`);
            this.pid_componet.update(`后台进程PID: ${res.pid}`);
            this.local_http_port.update(`本地HTTP监听: host: ${info.host} 端口: ${info.port}`);
            this.mem_rss_text.update(`-- 进程总内存: ${this.memUnitsConversion(res.memory_usage.rss)}`);
            this.mem_heap_total_text.update(`-- 堆内存-总量: ${this.memUnitsConversion(res.memory_usage.heapTotal)}`);
            this.mem_heap_used_text.update(`-- 堆内存-已分配: ${this.memUnitsConversion(res.memory_usage.heapUsed)}`);
            this.mem_external_text.update(`-- 链接库内存: ${this.memUnitsConversion(res.memory_usage.external)}`);
            this.state_componet.update(`健康状态: ${res.is_alive.healthy ? '在线' : '离线'}`);
        } catch (error) {
            this.state_componet.update(`健康状态: 离线`);
        }

    }

    /**
     * 
     * @param {Number} byte 
     * @returns 
     */
    memUnitsConversion(byte) {
        let units = 'B';
        let num = byte;
        if (num > 1024) {
            units = 'KB';
            num = num / 1024;
        }
        if (num > 1024) {
            units = 'MB';
            num = num / 1024;
        }
        if (num > 1024) {
            units = 'GB';
            num = num / 1024;
        }
        return num.toFixed(3) + units;
    }
}

export class AppAbout extends PaneContent {
    constructor(id) {
        super(id);
    }
    start() {
        this.component = new VBox({
            children: [
                new Text({ text: "* 小说蠕虫" }),
                new Text({ text: "* 简介: 这是一个管理小说、阅读小说的爬虫客户端，需要配置书源才能使用。" }),
                new Text({ text: "* 作者: ty" }),
                new Text({ text: '* 客户端组件版本: ' }),
                new Text({ text: `* -- Electron: ${local.electronVersion()}` }),
                new Text({ text: `* -- Chromium: ${local.chromeVersion()}` }),
                new Text({ text: `* -- Node: ${local.nodeVersion()}` }),
                new Text({ text: `* -- V8: ${local.v8Version()}` }),
            ]
        });
        this.dom = this.component.html();
    }
}

export class AppHelp extends PaneContent {
    constructor(id) {
        super(id);
    }
    start() {
        this.component = new VBox({
            children: [
                new Text({ text: "和阅读3.0一样也是爬取盗版小说网站的小说，不过因为使用nodejs编写，因此书源并不兼容" }),
            ]
        });
        this.dom = this.component.html();
    }
}